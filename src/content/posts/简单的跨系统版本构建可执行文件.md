---
title: 简单的跨系统版本构建可执行文件
published: 2026-01-08
tags: ['docker','go','linux']
description: '借助docker在本地快速构建适合不同系统版本的可执行文件'
category: '技术'
---

在实际开发中要构建对应系统版本的可执行文件,难免要装个虚拟机开发编译或者使用指定的编译工具链。本文要介绍的就是可以在不借助ci工具的情况在任意支持docker的本地快速构建的方法。

## 依赖

- docker
- make 可选

## 例子

这里就以实际开发中常见的rhel不同版本举例

### golang

在必须启用cgo的情况下，针对不同版本的glibc构建对应的可执行文件。

#### dockerfile

首先就是准备dockerfile简单举例2个

- build.rel7.dockerfile

```dockerfile
# 使用 CentOS 7 作为基础镜像
FROM centos:7

# 安装 wget 和 tar 用于下载和解压 Go 安装包
RUN curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo && \
 sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo && \
 yum makecache && \
 yum update -y && \
    yum install -y wget tar && \
    yum clean all

# 下载并解压指定版本的 Go
RUN wget https://golang.google.cn/dl/go1.24.2.linux-amd64.tar.gz && \
 tar -C /usr/local -xzf go1.24.2.linux-amd64.tar.gz && \
 rm go1.24.2.linux-amd64.tar.gz

# 设置 Go 环境变量
ENV PATH="/usr/local/go/bin:${PATH}"
ENV GOPATH="/go"
ENV PATH="${GOPATH}/bin:${PATH}"
ENV CGO_ENABLED=1

# 创建工作目录
WORKDIR /app

# 将项目代码复制到工作目录
COPY . .

# 构建 Go 可执行文件
RUN go build -o impala_export_rel7.out    

```

- build.rel10.dockerfile

``` dockerfile
FROM almalinux:10-kitten
# 安装 wget 和 tar 用于下载和解压 Go 安装包
RUN dnf makecache && \
 dnf update -y && \
 dnf install -y wget tar gzip && \
 dnf clean all

# 下载并解压指定版本的 Go
RUN wget https://golang.google.cn/dl/go1.24.2.linux-amd64.tar.gz && \
 tar -C /usr/local -xzf go1.24.2.linux-amd64.tar.gz && \
 rm go1.24.2.linux-amd64.tar.gz

# 设置 Go 环境变量
ENV PATH="/usr/local/go/bin:${PATH}"
ENV GOPATH="/go"
ENV PATH="${GOPATH}/bin:${PATH}"
ENV CGO_ENABLED=1

# 创建工作目录
WORKDIR /app

# 将项目代码复制到工作目录
COPY . .

# 构建 Go 可执行文件
RUN go build -o impala_export_rel10.out    
```

### makefile

这里就是一些构建命令

```makefile
# 定义变量
IMAGE_NAME := rel-go1.24.2-build
CONTAINER_NAME := rel-go1.24.2-container
PROJECT_DIR := $(shell pwd)
OUTPUT_DIR := $(PROJECT_DIR)/output

# 默认目标，依次执行构建、拷贝和清理操作
all_rel7: build_rel7 copy_rel7 clean_rel7

all_rel10: build_rel10 copy_rel10 clean_rel10
# 创建输出目录并构建 Docker 镜像
build_rel7:
 mkdir -p $(OUTPUT_DIR)
 docker build -t $(IMAGE_NAME):7 -f build.rel7.dockerfile .

build_rel10:
 mkdir -p $(OUTPUT_DIR)
 docker build -t $(IMAGE_NAME):10 -f build.rel10.dockerfile .
# 运行容器并从容器中拷贝可执行文件到本地输出目录
copy_rel7:
 docker rm $(CONTAINER_NAME) || echo "not find $(CONTAINER_NAME)"
 docker run --name $(CONTAINER_NAME) $(IMAGE_NAME):7 /bin/true
 docker cp $(CONTAINER_NAME):/app/impala_export_rel7.out $(OUTPUT_DIR)

copy_rel10:
 docker rm $(CONTAINER_NAME) || echo "not find $(CONTAINER_NAME)"
 docker run --name $(CONTAINER_NAME) $(IMAGE_NAME):10 /bin/true
 docker cp $(CONTAINER_NAME):/app/impala_export_rel10.out $(OUTPUT_DIR)
# 删除容器和镜像
clean_rel7:
 docker rm $(CONTAINER_NAME)
 docker rmi $(IMAGE_NAME):7
 echo "构建完成，可执行文件已生成在 $(OUTPUT_DIR)/impala_export_rel7.out"

clean_rel10:
 docker rm $(CONTAINER_NAME)
 docker rmi $(IMAGE_NAME):10
 echo "构建完成，可执行文件已生成在 $(OUTPUT_DIR)/impala_export_rel10.out"
 
# 清理输出目录
clean-output:
 rm -rf $(OUTPUT_DIR)
 echo "输出目录已清理"    
```

### 构建

执行命令`make all_rel7`在最后就可以得到对应的可执行文件，而不用在本地去配置麻烦的虚拟机或者编译链了。

## 总结

这种方法最适合的是本地快速构建出一个可以跑的可执行文件，而且相对简单依赖少。同样的这个也非常适合打包其他编程语言，针对不同的系统版本使用不同的基础镜像。
